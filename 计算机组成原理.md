

# 计算机组成原理

##### 1.1 什么是信息

为了更好的保存和传输信息，我们需要一些工程工具

信息是减小特定事件不确定性的物质。 即：使事件的不确定性变得最小的数据，所蕴含的信息量越大。

##### 1.2  量化信息

定义事件：
$$
x_1,x_2,x_3\cdots
$$
对应事件的概率：
$$
p_1,p_2,p_3\cdots
$$
则对应的事件的不确定性为：
$$
I(x_i)=log_2(\frac{1}{p_i})
$$
即事件的不确定性与事件的概率成反比。

比如：抛出两枚硬币，对应每一个事件个概率为1/4,对应的每个事件的不确定性则为2。

克劳德.香农将信息量的单位定义为比特(bit)。同理，抛出两个骰子，当我们获得结果，我们所获得的信息量为
$$
log_236=5.17 bit
$$

##### 1.3 熵

随机变量(X)：一个事件的集合，集合中所有事件的概率和为1.

熵(H)：随机变量的平均信息量，即期望(E)
$$
H(X)=E(I(X))=\sum_{i=1}^{N}{p_i}\cdot\log_2(\frac{1}{p_i})
$$
例 1.1 ：X={A,B,C,D}

| 事件 | 概率 | 信息量   |
| ---- | ---- | -------- |
| A    | 1/3  | 1.58 bit |
| B    | 1/2  | 1 bit    |
| C    | 1/12 | 3.58 bit |
| D    | 1/12 | 3.58 bit |

$$
H(X)=((1/3)\cdot1.58+(1/2)\cdot1+(1/12)\cdot3.58+(1/12)\cdot3.58)=1.63 bit
$$

由此可得，存在比定长编码(2 bit)更好的编码方式.

结论：熵是我们确定传输一个随机变量的信息量的下限。

##### 1.4 编码

编码是位字符串与编码对象之间的明确映射。

比如例 1.1 ，我们可以定长编码为：

| A    | B    | C    | D    |
| ---- | ---- | ---- | ---- |
| 00   | 01   | 10   | 11   |

由此，我们可以明确地将一组信息进行编码：ABBA ->00010100

也可以明确地将一串位字符串解码为信息：00100001 -> ACAB

不会发生歧义。

我们也可以进行变长编码：

| A    | B    | C    | D    |
| ---- | ---- | ---- | ---- |
| 01   | 1    | 000  | 001  |

同样可以编码：ABBA -> 011101

且解码一不会发生歧义。

对此可以表示为一棵二叉树,树的左右连接为0,1，树的叶子节点为对应的编码对象，而从根节点到达叶子节点的边的顺序就是对象的编码字符串。编码字符串循环地从根节点到达叶子节点就是进行解码

##### 1.5 符号整数的编码

符号整数以32位进行编码，第32为为符号位，1为负数，0为正数。

但是在正负数计算中就会出现问题，存在+0与-0，所以，大部分数字电路使用二进制补码。

即在计算中，最大的负数为100...000,最大的正数为011...111,二者之和为-1,即111...11。0为000..00

A+(-A)=1+(-1)

-A=(-1-A)+1

-A=~A+1

所以，一个数的相反数就它的取反再加1.

##### 1.6 变长编码

根据信息熵公式，已知不同概率的事件的集合，变长编码存在比定长编码更高效率的可能。

通俗地说，高概率的事件应该使用较短的编码，而低概率事件则应该使用较长的编码。

同样使用例 1.1 ，已知其信息熵为1.63 bit，进行变长编码后，其信息熵为
$$
(1/3)\cdot2+(1/2)\cdot1+(1/12)\cdot3\cdot2=1.67 bit
$$
明显低于定长编码的2 bit.

##### 1.7 霍夫曼算法

霍夫曼算法给我们一种构造最优变长编码的方式，该算法基于二叉树自下而上地构建编码。

1. 选择集合中两个概率最小的元素作为子树的叶子节点，由于概率最小，所以它们的编码长度应该最长
2. 叶子节点的子树概率为叶子节点概率之和，从集合中删除这两个符号，子树作为新元素加入集合
3. 重复1,2步骤，直至集合中只存在一个元素

##### 1.8 检错

汉明距离(码距)：用于测量两个编码的差异的工具。两个编码之间，相同位不同编码的数量越多，汉明距离越大。

码距越大，两个编码就越不可能因为噪音发生错误识别。

一个编码系统中，任意两个码字之间的最小汉明距离就是这个系统的码距。

奇偶校验：在编码中固定位置增加冗余位，使得编码的所有位的和为奇数/偶数。这种方式可以校验出编码的奇数位发生错误，但无法校验出偶数位错误。奇偶校验存在垂直奇偶校验与水平奇偶校验。

垂直奇偶校验：在编码发送过程中，对发送的数据添加校验位。这种方式发送方可以一边发送一边添加校验，接收方也可以一边接收一边进行校验，这种方式的漏检率同样是1/2.

水平奇偶校验：对于已发送的多段数据的相同位上添加校验位。这种方式要求双方都拥有缓冲区，每发送完数据都需要发送一段校验数据。水平奇偶校验还可以检查出某段发送数据突发长度<=p的错误，所以水平奇偶校验的漏检率小于1/2。

纵横奇偶校验：同时进行水平奇偶校验和垂直奇偶校验。水平垂直奇偶校验能检测出所有3位或3位以下的错误(因为此时至少在某一行或某一'列上有一位错)、奇数位错、突发长度<=p+1的突发错以及很大一部分偶数位错。测量表.明,这种方式的编码可使误码率降至原误码率的百分之一到万分之一。水平垂直奇偶校验不仅可检错,还可用来纠正部分差错。例如数据块中仅存在1位错'时,便能确定错码的位置就在某行和某列的交叉处,从而可以纠正它。

通过添加冗余位来增加两个编码之间的汉明距离，使得避免发生E(汉明距离为E+1)的错误。

##### 1.9 纠错

码距越大纠错能力就越强，但是编码效率就越低。

当编码的汉明距离为2*E+1时，我们可以纠正E位的编码错误。
